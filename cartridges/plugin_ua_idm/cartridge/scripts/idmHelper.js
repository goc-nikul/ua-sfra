'use strict';
/*
 * API Includes
 */
const idmService = require('~/cartridge/scripts/services/idmService.js');
const idmLogger = require('dw/system/Logger').getLogger('IDM', 'IDM');
const idmPreferences = require('~/cartridge/scripts/idmPreferences.js');
const CustomerMgr = require('dw/customer/CustomerMgr');
const Transaction = require('dw/system/Transaction');
const URLUtils = require('dw/web/URLUtils');
const Site = require('dw/system/Site');
const StringUtils = require('dw/util/StringUtils');
const Logger = require('dw/system/Logger');
var formErrors = require('*/cartridge/scripts/formErrors');
var accountHelpers = require('*/cartridge/scripts/helpers/accountHelpers');
var server = require('server');
var Resource = require('dw/web/Resource');
const idmConstants = {
    userDomain: 'UACF',
    domainUserId: 'AUTO',
    accountLinksDomain: idmPreferences.accountLinksDomain
};

var errorCodes = {
    ERROR_INVALID_INPUT: 400,
    ERROR_DUPLICATE_CUSTOMER: 409
};
var isMX = Site.current.ID === 'MX';
/**
 * Generates JWT signature by specified key
 * @Param {Object} payload
 * Example payload = {
 *              username: username,
 *              password: password
 *        }
 * @return {string} JWT - If generated successfully, else null
 */
function getIDMCredentials(payload) {
    let credentials;
    try {
        if (!empty(payload)) {
            const jsrsasign = require('~/cartridge/scripts/jsrsasign'); // eslint-disable-line spellcheck/spell-checker
            const jwt = jsrsasign.jws.JWS; // eslint-disable-line spellcheck/spell-checker
            const alg = null;
            const pass = null;
            const header = {
                alg: 'HS512',
                kid: idmPreferences.jwtSigningKeyId
            };
            const key = {
                b64u: idmPreferences.jwtSigningKey
            };
            credentials = jwt.sign(alg, header, payload, key, pass);
        }
    } catch (e) {
        idmLogger.error('Error while generating JWT :: IDMHelper.js -> getIDMCredentials() :: {0}', e.message);
    }
    return credentials;
}
/**
 * Returns redirectURI
 * @return {string} absURL - returns redirectURI
 */
function getRedirectURI() {
    var absURL = '';
    var regex = new RegExp('^(http|https)://');
    var redirectURI = idmPreferences.redirectURI;
    var absURLAvailable = regex.test(redirectURI);
    if (absURLAvailable) {
        absURL = redirectURI;
    } else {
        redirectURI = redirectURI.indexOf('/') > -1 ? redirectURI.split('/')[redirectURI.split('/').length - 1] : redirectURI;
        absURL = URLUtils.abs(redirectURI).toString();
    }
    return absURL;
}

/**
 * Verify if the response is force password reset
 * @Param {dw.svc.Result} result - Represents the result of a service call.
 * @return {boolean} isForcedPasswordReset
 */
function isForcedPasswordReset(result) {
    if (result && !empty(result.object) && !empty(result.object.text)) {
        const responseJSON = JSON.parse(result.object.text);
        const error = 'error' in responseJSON && !empty(responseJSON.error) ? responseJSON.error : null;
        const reason = 'reason' in responseJSON && !empty(responseJSON.reason) ? responseJSON.reason : null;

        if (error === 'access_denied' && reason === '100') return true;
    }

    return false;
}

/**
 * Extracts and returns authorization code
 * @Param {string} credentials - JWT signature, generated by payload and specified key
 * @return {Object} authorizationCodeResult - success status and code if received successfully else error status.
 */
function getAuthorizationCode(credentials) {
    let authorizationCodeResult = {
        status: 'ERROR_UNKNOWN',
        code: null
    };
    try {
        if (!empty(credentials)) {
            const redirectURI = getRedirectURI();
            const service = idmService.createIDMService();
            service.URL += '/oauth/authorize';
            service.setRequestMethod('GET');
            service.addParam('client_id', idmPreferences.clientId);
            service.addParam('credentials', credentials);
            service.addParam('response_type', 'code');
            service.addParam('redirect_uri', redirectURI);
            if (Site.current.status === Site.SITE_STATUS_PROTECTED) {
                // Set basic authorization header if the site is password-protected
                service.addHeader('Authorization', 'Basic ' + StringUtils.encodeBase64('storefront:' + idmPreferences.storefrontPassword));
            }
            var result = service.call();
            if (!empty(result)) {
                if (!empty(result.status) && result.status === 'SERVICE_UNAVAILABLE') {
                    // Service unavailable
                    authorizationCodeResult.status = 'ERROR_SERVICE_UNAVAILABLE';
                } else if (!empty(result.error) && result.error === 500) {
                    // Error code 500 - invalid JWT or Server Error
                    authorizationCodeResult.status = 'ERROR_INVALID_JWT';
                } else if (idmPreferences.enableForcePasswordReset && isForcedPasswordReset(result)) {
                    // Access denied - forced password reset required for user.
                    authorizationCodeResult.status = 'ERROR_PASSWORD_RESET_REQUIRED';
                } else if (!empty(result.object) && !empty(result.object.text)) {
                    const responseJSON = JSON.parse(result.object.text);
                    if ('code' in responseJSON && !empty(responseJSON.code)) {
                        // Code received successfully
                        authorizationCodeResult = {
                            status: 'SUCCESS',
                            code: responseJSON.code
                        };
                    } else if ('error' in responseJSON && !empty(responseJSON.error)) {
                        // Access denied - Invalid user name or password
                        authorizationCodeResult.status = 'ERROR_PASSWORD_MISMATCH';
                    }
                }
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> getAuthorizationCode() :: {0}', e.message);
    }
    return authorizationCodeResult;
}

/**
 * Makes service call to get access token and returns if received successfully, Else null
 * @Param {string} grantType - [Example - authorization_code, client_credentials]
 * @Param {string} code - if authorization_code, else null
 * @return {Object} tokenResponse JSON object
 */
function getAccessToken(grantType, code) {
    let tokenResponse;
    const redirectURI = getRedirectURI();
    try {
        const service = idmService.createIDMService();
        service.URL += '/oauth/token';
        service.setRequestMethod('POST');
        service.addParam('grant_type', grantType);
        service.addParam('client_id', idmPreferences.clientId);
        service.addParam('client_secret', idmPreferences.clientSecret);
        if (!empty(code)) {
            if (grantType === 'refresh_token') {
                service.addParam('refresh_token', code);
            } else {
                service.addParam('code', code);
                service.addParam('redirect_uri', redirectURI);
            }
        }
        service.addParam('auto_create_account_link', true);
        const result = service.call();
        if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)) {
            tokenResponse = JSON.parse(result.object.text);
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> getCustomerToken() :: {0}', e.message);
    }
    return tokenResponse;
}

/**
 * Update IDM Locale
 * @param {string} userID IDM userid
 * @param {Object} sizePreferences current sizePreferences
 * @param {string} accessToken user's access token
 * @returns {boolean} status of locale updation
 */
function updateSizePreferences(userID, sizePreferences, accessToken) {
    const service = idmService.createIDMService();
    service.URL += '/v2/users/' + userID;
    service.setRequestMethod('PATCH');
    service.addHeader('Content-Type', 'application/json');
    service.addHeader('Accept', 'application/json');
    service.addHeader('Authorization', 'Bearer ' + accessToken);
    const userInfo = {
        profile: {
            sizePreferences: sizePreferences
        }
    };
    const result = service.call(JSON.stringify(userInfo));
    return !empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)
           ? JSON.parse(result.object.text)
           : null;
}

/**
 * Update IDM Locale
 * @param {string} userID IDM userid
 * @param {string} localeID current site localeID
 * @param {string} accessToken user's access token
 * @returns {boolean} status of locale updation
 */
function updateIDMLocale(userID, localeID, accessToken) { // eslint-disable-line
    const service = idmService.createIDMService();
    service.URL += '/v2/users/' + userID;
    service.setRequestMethod('PATCH');
    service.addHeader('Content-Type', 'application/json');
    service.addHeader('Accept', 'application/json');
    service.addHeader('Authorization', 'Bearer ' + accessToken);
    const userInfo = {
        profile: {
            locale: localeID
        }
    };
    const result = service.call(JSON.stringify(userInfo));
    return !empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)
           ? JSON.parse(result.object.text)
           : null;
}

/**
 * Get IDM UserID by email
 * @param {string} emailAddress customer email
 * @param {string} accessToken IDM client token
 * @returns {string} IDM UserID or null
 */
function getUserIDByEmail(emailAddress, accessToken) { // eslint-disable-line
    const service = idmService.createIDMService();
    service.URL += '/users/search?emailAddress=' + emailAddress;
    service.setRequestMethod('GET');
    service.addHeader('Content-Type', 'application/json');
    service.addHeader('Accept', 'application/json');
    service.addHeader('Authorization', 'Bearer ' + accessToken);
    const result = service.call();

    if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)) {
        let IDMUsers = JSON.parse(result.object.text);
        for (let i = 0; i < IDMUsers.length; i++) {
            let user = IDMUsers[i];
            if (user.domain === 'UACF') {
                return user.userId_str;
            }
        }
    }
    return null;
}
/**
 * Makes service call to get user info
 * @Param {string} accessToken - Bearer token
 * @return {Object} customerInfo - JSON object
 */
function getCustomerInfo(accessToken) {
    let customerInfo;
    try {
        if (!empty(accessToken)) {
            const service = idmService.createIDMService();
            service.URL += '/v2/userinfo'; // eslint-disable-line spellcheck/spell-checker
            service.setRequestMethod('GET');
            service.addHeader('content-type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);
            const result = service.call();
            if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)) {
                customerInfo = JSON.parse(result.object.text);
                // update locale with request locale
                customerInfo.profile.locale = request.locale; // eslint-disable-line
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> getCustomerInfo() :: {0}', e.message);
    }
    return customerInfo;
}
/**
 * Makes service call to get user loyalty info
 * @Param {string} accessToken - Bearer token
 * @Param {string} idmUserId - UACF ID
 * @return {Object} customerLoyaltyInfo - JSON object
 */
function getCustomerLoyaltyInfo(accessToken, idmUserId) {
    let customerLoyaltyInfo;
    try {
        if (!empty(accessToken)) {
            const service = idmService.createIDMService();
            service.URL += '/v2/users/' + idmUserId; // eslint-disable-line spellcheck/spell-checker
            service.setRequestMethod('GET');
            service.addHeader('content-type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);
            const result = service.call();
            if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object) && !empty(result.object.text)) {
                customerLoyaltyInfo = JSON.parse(result.object.text);
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> getCustomerLoyaltyInfo() :: {0}', e.message);
    }
    return customerLoyaltyInfo;
}
/**
 * Prepare the Payload object
 * @Param {string} username - username
 * @Param {string} password - password
 * @Param {Object} socialInfo - socialInfo
 * @return {Object} payload - JSON object
 */
function getPayLoad(username, password, socialInfo) {
    var payload = {};
    if (!empty(socialInfo)) {
        payload.uacf_social_provider = socialInfo.providerID;
        payload.uacf_social_appid = ('appID' in socialInfo && !empty(socialInfo.appID)) ? socialInfo.appID : idmPreferences.fbAppID;
        payload.uacf_social_oauthtoken = socialInfo.authToken;
        payload.update_profile = ('updateProfile' in socialInfo && !empty(socialInfo.updateProfile)) ? socialInfo.updateProfile : 'false';
    } else {
        payload.username = username;
        payload.password = password;
    }
    return payload;
}

/**
 * updates IDM access token to SFCC custom attribute
 * @Param {Object} authenticatedCustomer - Customer
 * @param {Object} authenticateCustomerResult idm auth result
 */
function updateTokenOnLogin(authenticatedCustomer, authenticateCustomerResult) {
    try {
        if (!empty(authenticatedCustomer) && !empty(authenticateCustomerResult)) {
            Transaction.wrap(function () {
                if (authenticatedCustomer.profile && authenticatedCustomer.profile.custom) {
                    if (!empty(authenticateCustomerResult.accessToken)) {
                        authenticatedCustomer.profile.custom.idmAccessToken = authenticateCustomerResult.accessToken;// eslint-disable-line no-param-reassign
                    }
                    // store IDM refresh token
                    if (!empty(authenticateCustomerResult.refreshToken)) {
                        authenticatedCustomer.profile.custom.idmRefreshToken = authenticateCustomerResult.refreshToken;// eslint-disable-line no-param-reassign
                    }
                    // Calculate token expiration time
                    if (!empty(authenticateCustomerResult.expiresIn)) {
                        var expiresIn = parseInt(authenticateCustomerResult.expiresIn) / 60; // eslint-disable-line
                        var expirationTime = new Date();
                        expirationTime.setTime(expirationTime.valueOf() + Site.getCurrent().timezoneOffset);
                        var updatedTime = expirationTime.getMinutes() + expiresIn;
                        expirationTime.setMinutes(updatedTime);
                        authenticatedCustomer.profile.custom.idmAccessTokenExpiresIn = expirationTime;// eslint-disable-line no-param-reassign
                    }
                }
            });
        }
    } catch (e) {
        Logger.error('Error while executing updateTokenOnLogin function' + JSON.stringify(e));
    }
}

/**
 * Updates IDM access_token using refresh_token if token is expired
 * @Param {Object} customer - Current Customer
 * @Param {string} username - email of customer
 * @return {Object} authenticationResult - IDM service call response
 */
function getNewAccessTokenIfExpired(customer, username) {
    // Logic to refresh token if access token is expired
    var authenticationResult = {};
    var dateAndTimeNow = new Date();
    dateAndTimeNow.setTime(dateAndTimeNow.valueOf() + Site.getCurrent().timezoneOffset);
    var tokenExpirationTime = customer.profile && customer.profile.custom && 'idmAccessTokenExpiresIn' in customer.profile.custom && customer.profile.custom.idmAccessTokenExpiresIn;
    if (dateAndTimeNow >= tokenExpirationTime) {
        // genarate new access token as current one is expired
        var refreshToken = customer.profile && customer.profile.custom && 'idmRefreshToken' in customer.profile.custom && customer.profile.custom.idmRefreshToken;
        if (refreshToken) {
            var tokenResponse = getAccessToken('refresh_token', refreshToken);
            if (!empty(tokenResponse)) {
                if ('access_token' in tokenResponse && !empty(tokenResponse.access_token)) {
                    idmLogger.debug('Access token generated for user {0} using refresh_token.', username);
                    authenticationResult.accessToken = tokenResponse.access_token;
                    authenticationResult.tokenSuccess = true;
                }
                if ('refresh_token' in tokenResponse && !empty(tokenResponse.refresh_token)) {
                    authenticationResult.refreshToken = tokenResponse.refresh_token;
                }
                if ('expires_in' in tokenResponse && !empty(tokenResponse.expires_in)) {
                    authenticationResult.expiresIn = tokenResponse.expires_in;
                }
            } else {
                authenticationResult.tokenSuccess = false;
            }
        }
    }
    return authenticationResult;
}

/**
 * Get IDM access_token from current customer profile if it is not expired
 * @return {string} access_token or empty string
 */
function getTokenFromProfile() {
    if (!customer || !customer.profile) {
        return '';
    }

    var dateAndTimeNow = new Date();
    dateAndTimeNow.setTime(dateAndTimeNow.valueOf() + Site.getCurrent().timezoneOffset);

    var tokenExpirationTime = customer.profile.custom.idmAccessTokenExpiresIn;
    var tokenFromProfile = customer.profile.custom.idmAccessToken;

    if (tokenFromProfile && tokenExpirationTime && dateAndTimeNow < tokenExpirationTime) {
        return tokenFromProfile;
    }

    return '';
}

/**
/**
 * Authenticates user by username and password
 * @Param {string} username - IDM account username
 * @Param {string} password - IDM account password
 * @Param {Object} socialInfo - IDM account social info
 * @return {Object} authenticationResult - 'AUTH_OK' and external profile data if customer Authenticated successfully, else error status.
 */
function authenticateCustomer(username, password, socialInfo) {
    const AuthenticationStatus = require('dw/customer/AuthenticationStatus');
    let authenticationResult = {
        status: AuthenticationStatus.ERROR_UNKNOWN,
        externalProfile: null,
        tokenSuccess: false,
        accessToken: null,
        refreshToken: null
    };
    try {
        if ((!empty(username) && !empty(password)) || !empty(socialInfo)) {
            var payload = getPayLoad(username, password, socialInfo);
            const credentials = getIDMCredentials(payload);
            if (!empty(credentials)) {
                idmLogger.debug('JWT for user {0} generated.', username);
                const authorizationCodeResult = getAuthorizationCode(credentials);
                if (authorizationCodeResult.status === 'SUCCESS' && !empty(authorizationCodeResult.code)) {
                    idmLogger.debug('Auth code received for user {0}.', username);
                    const tokenResponse = getAccessToken('authorization_code', authorizationCodeResult.code);
                    if (!empty(tokenResponse)) {
                        if ('access_token' in tokenResponse && !empty(tokenResponse.access_token)) {
                            idmLogger.debug('Access token received for user {0}.', username);
                            authenticationResult.accessToken = tokenResponse.access_token;
                            authenticationResult.tokenSuccess = true;
                        }
                        if ('refresh_token' in tokenResponse && !empty(tokenResponse.refresh_token)) {
                            authenticationResult.refreshToken = tokenResponse.refresh_token;
                        }
                        if ('expires_in' in tokenResponse && !empty(tokenResponse.expires_in)) {
                            authenticationResult.expiresIn = tokenResponse.expires_in;
                        }
                    }
                } else {
                    authenticationResult.status = authorizationCodeResult.status;
                }
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> authenticateCustomer() :: {0}', e.message);
    }
    return authenticationResult;
}
/**
 * set cookie for external profile user in IDM
 * api.cookie.maxValueLength
 * Default Limit: 2,000 (warning at 1,200)
 * Quota api.cookie.maxValueLength (not enforced, warn 1200, limit 2000): limit exceeded.
 * @Param {string} cookieName - IDM cookieName
 * @Param {string} cookieValue - IDM cookieValue
 */
function setCookie(cookieName, cookieValue) {
    var Cookie = require('dw/web/Cookie');
    var cookie = new Cookie(cookieName, cookieValue);
    var loginTime = Site.current.preferences.custom.uaidmPersistantSession;
    cookie.setMaxAge(loginTime);
    cookie.setPath('/');
    cookie.setHttpOnly(true);
    response.addHttpCookie(cookie); // eslint-disable-line
}
/**
 * updates UAExternalID cookie on every login and save account.
 * @Param {Object} externalProfile - IDM user info JSON object
 * @param {string} userId domain userId
 * @param {string} exPRdomain domain
 */
function updateIDMCookie(externalProfile, userId, exPRdomain) {
    try {
        if (!empty(externalProfile)) {
            if (empty(userId) || empty(exPRdomain)) {
                // Under Armour NA ECOM POC special case
                if (externalProfile.accountLinks && externalProfile.accountLinks.length > 0) {
                    var collections = require('*/cartridge/scripts/util/collections');
                    var ArrayList = require('dw/util/ArrayList');
                    var accountLinks = new ArrayList(externalProfile.accountLinks);
                    var ecommAccountLink = collections.find(accountLinks, function (accountLink) {
                        return accountLink.domain === idmConstants.accountLinksDomain;
                    });
                    userId = !empty(ecommAccountLink) && !empty(ecommAccountLink.domainUserId) ? ecommAccountLink.domainUserId : ''; // eslint-disable-line
                    exPRdomain = !empty(ecommAccountLink) && !empty(ecommAccountLink.domain) ? ecommAccountLink.domain : ''; // eslint-disable-line
                }
            }
            var externalProfileAttributes = {
                profile: {
                    firstName: externalProfile.profile.firstName,
                    lastName: externalProfile.profile.lastName,
                    gender: externalProfile.profile.gender,
                    profilePictureUri: externalProfile.profile.profilePictureUri,
                    employeeLevel: externalProfile.profile.employeeLevel,
                    vipAccountNumber: externalProfile.profile.vipAccountNumber,
                    birthdate_obj: externalProfile.profile.birthdate_obj,
                    domainUserId: !empty(userId) ? userId : externalProfile.profile.domainUserId,
                    domain: !empty(exPRdomain) ? exPRdomain : externalProfile.profile.domain,
                    email: !empty(externalProfile.emails) ? externalProfile.emails[0].email : externalProfile.email,
                    preferences: externalProfile.profile.preferences
                }
            };
            setCookie('UAExternalID', encodeURI(JSON.stringify(externalProfileAttributes)));
        }
    } catch (e) {
        Logger.error('Error while executing updateIDMCookie function' + JSON.stringify(e));
    }
}
/**
 * updates customer data in SFCC from external profile
 * @param {Object} customerProfile - authenticated current customer profile
 * @Param {Object} externalProfile - IDM user info JSON object
 * @Param {Object} exPRSizePreferences - IDM user info JSON object
 */
function updateCurrentCustomerInfo(customerProfile, externalProfile) {
    var firstName;
    var secondName;
    var lastName;
    var email = '';
    var birthdayObj;
    var custBirthMonth;
    var custBirthDay;
    var custBirthYear;
    var gender;
    var profilePictureUri;
    var employeeLevel;
    var employeeCountry;
    var vipAccountNumber;
    var preferences;
    var birthday = null;
    var preferredLocale = null;
    var phone = '';
    var postalCode;
    var loyaltyID = '';
    var loyaltyStatus;
    var loyaltyStatusDate;

    try {
        if (externalProfile && typeof externalProfile.profile === 'object') {
            // Under Armour NA ECOM POC special case
            firstName = externalProfile.profile.firstName;
            lastName = externalProfile.profile.lastName;
            gender = externalProfile.profile.gender;
            profilePictureUri = externalProfile.profile.profilePictureUri;
            employeeLevel = externalProfile.profile.employeeLevel;
            employeeCountry = 'employee' in externalProfile.profile && typeof externalProfile.profile.employee === 'object' && 'country' in externalProfile.profile.employee && !empty(externalProfile.profile.employee.country) ? externalProfile.profile.employee.country : '';
            vipAccountNumber = externalProfile.profile.vipAccountNumber;
            if ('preferences' in externalProfile.profile) {
                preferences = externalProfile.profile.preferences;
            }
            birthdayObj = externalProfile.profile.birthdate_obj;
            loyaltyStatus = 'loyaltyStatus' in externalProfile ? externalProfile.loyaltyStatus : '';
            loyaltyStatusDate = 'loyaltyStatusDate' in externalProfile ? externalProfile.loyaltyStatusDate : '';
            preferredLocale = request.locale; // eslint-disable-line
        }
        // Update customer email
        if (externalProfile.email || externalProfile['email-address']) {
            email = externalProfile.email // OpenID Connect standard claim
            ||
            externalProfile['email-address'];
        }
        if (!email) {
            var emails = externalProfile.emails;

            if (emails && emails.length) {
                email = emails[0] ||
                emails[0].value;
            }
        }
        // Update Loyalty ID
        if (!empty(externalProfile.loyaltyID) && externalProfile.loyaltyID !== null) {
            loyaltyID = externalProfile.loyaltyID;
        }
        // Update Enrollment Status Date
        if (!empty(loyaltyStatusDate) && loyaltyStatusDate !== null) {
            loyaltyStatusDate = new Date(loyaltyStatusDate.slice(0, 10));
        }
        if (birthdayObj) {
            custBirthMonth = birthdayObj.month;
            custBirthDay = birthdayObj.day;
            if (birthdayObj.year) {
                custBirthYear = birthdayObj.year;
            }
        }
        // Update customer birthday
        // Setting customer birthdate only when we receive Month and Day in response
        if (custBirthMonth && custBirthDay) {
            var custYearStatic = '1904'; // As we are not receving the customer year, keeping it static
            custBirthMonth = parseInt(custBirthMonth, 10);
            custBirthDay = parseInt(custBirthDay, 10);
            if (custBirthYear) {
                birthday = new Date(custBirthYear, custBirthMonth - 1, custBirthDay);
            } else {
                birthday = new Date(custYearStatic, custBirthMonth - 1, custBirthDay); // form Date Object
            }
        }
        // Update customer gender
        gender = empty(gender) ? externalProfile.gender : gender; // OpenID Connect standard claim
        if (gender) {
            // Case-insensitive match vs. values of Profile.gender system attribute
            // (Enum of Int type), configurable in Business Manager.

            var genderAttrDef = customerProfile.describe().getSystemAttributeDefinition('gender');
            var genderAttrValues = genderAttrDef.getValues();
            genderAttrValues = genderAttrValues.toArray();
            var genderAttrMatch = genderAttrValues.filter(function (attrValue) {
                return (RegExp('^' + gender + '$', 'i').test(attrValue.getDisplayValue()));
            }).pop();

            if (genderAttrMatch) {
                gender = genderAttrMatch.value;
            }
        }
        if (!gender) gender = 0;
        Transaction.wrap(function () {
            if (!empty(firstName)) {
                customerProfile.setFirstName(firstName);
            }
            customerProfile.setSecondName(secondName);
            if (!empty(lastName)) {
                customerProfile.setLastName(lastName);
            }
            if (empty(customerProfile.email)) {
                customerProfile.setEmail(email);
            }
            if (empty(customerProfile.custom.loyaltyID) || customerProfile.custom.loyaltyID === 'undefined') {
                customerProfile.custom.loyaltyID = loyaltyID; // eslint-disable-line no-param-reassign
            }
            if (!empty(loyaltyStatus) && loyaltyStatus !== null) {
                customerProfile.custom.loyaltyStatus = loyaltyStatus; // eslint-disable-line no-param-reassign
            }
            if (!empty(loyaltyStatusDate) && loyaltyStatusDate !== null) {
                customerProfile.custom.loyaltyStatusDate = loyaltyStatusDate; // eslint-disable-line no-param-reassign
            }
            customerProfile.setBirthday(birthday);
            if (custBirthDay) {
                customerProfile.custom.birthDay = custBirthDay.toString(); // eslint-disable-line no-param-reassign
            }
            if (custBirthMonth) {
                customerProfile.custom.birthMonth = custBirthMonth.toString(); // eslint-disable-line no-param-reassign
            }
            if (custBirthYear) {
                customerProfile.custom.birthYear = custBirthYear.toString(); // eslint-disable-line no-param-reassign
            }
            // For MX we also store birthday in 'dob' attribute
            if (isMX && custBirthDay && custBirthMonth && custBirthYear) {
                var dob = custBirthDay + '/' + custBirthMonth + '/' + custBirthYear;
                // Transform D/M/YYYY to DD/MM/YYYY
                dob = dob.replace(/\b\d\b/g, '0$&');
                customerProfile.custom.dob = dob; // eslint-disable-line no-param-reassign
            }
            customerProfile.setGender(gender);
            if ('phone' in externalProfile.profile) {
                phone = externalProfile.profile.phone;
                var countryDialingCode;
                if (phone && phone.indexOf('-') >= 0) {
                    var phoneNumber = phone.split('-');
                    if (phoneNumber.length === 2) {
                        phone = phoneNumber[1];
                        countryDialingCode = phoneNumber[0];
                        try {
                            // countryDialingCode attribute apepars to be in APAC only.
                            customerProfile.custom.countryDialingCode = countryDialingCode; // eslint-disable-line no-param-reassign
                        } catch (e) {} // eslint-disable-line no-empty
                    }
                }
                customerProfile.setPhoneHome(phone);
            }
            customerProfile.custom.isEmployee = !!employeeLevel && employeeLevel.toLowerCase() === 'employee'; // eslint-disable-line no-param-reassign
            customerProfile.custom.employeeCountry = !empty(employeeCountry) ? employeeCountry : ''; // eslint-disable-line no-param-reassign
            customerProfile.custom.vipAccountId = !empty(vipAccountNumber) ? vipAccountNumber : ''; // eslint-disable-line no-param-reassign
            customerProfile.custom.preferences = !empty(preferences) ? JSON.stringify(preferences) : ''; // eslint-disable-line no-param-reassign
            customerProfile.custom.profilePictureUri = !empty(profilePictureUri) ? profilePictureUri : ''; // eslint-disable-line no-param-reassign
            if ('location' in externalProfile.profile && !empty(externalProfile.profile.location) && externalProfile.profile.location.postalCode) {
                postalCode = externalProfile.profile.location.postalCode;
                customerProfile.custom.zipCode = postalCode; // eslint-disable-line no-param-reassign
            }
            if (preferredLocale) {
                customerProfile.preferredLocale = preferredLocale; // eslint-disable-line no-param-reassign
            }
        });
    } catch (error) {
        idmLogger.error('Error in IDMHelper.js -> updateCurrentCustomerInfo() :: {0}', error.message);
    }
}
/**
 * Check IDM user profile in SFCC, login if already exist, else create an externally authenticated customer and login.
 * @Param {Object} externalProfile - IDM user info JSON object
 * @param {boolean} rememberMe - Boolean value indicating if the customer wants to be remembered on the current computer
 * @return {dw.customer.Customer} customer -  dw.customer.Customer object if logged in successfully, else null
 * @Param {Object} exPRSizePreferences - IDM user info JSON object
 */
function loginCustomer(externalProfile, rememberMe, exPRSizePreferences) {
    let customer = null;
    try {
        if (!empty(externalProfile)) {
            var userId; // = externalProfile.sub || externalProfile.id || externalProfile.uid; // OpenID Connect standard claim
            var exPRdomain;
            // Under Armour NA ECOM POC special case OR
            // Account previously created with LRA integration
            if (externalProfile.accountLinks && externalProfile.accountLinks.length > 0) {
                var collections = require('*/cartridge/scripts/util/collections');
                var ArrayList = require('dw/util/ArrayList');
                var accountLinks = new ArrayList(externalProfile.accountLinks);
                var ecommAccountLink = collections.find(accountLinks, function (accountLink) {
                    return accountLink.domain === idmConstants.accountLinksDomain;
                });

                if (!ecommAccountLink) {
                    throw new Error('Domain  User ID Not exists');
                }
                userId = ecommAccountLink.domainUserId;
                exPRdomain = ecommAccountLink.domain;
            } else if (empty(userId) && externalProfile.profile.domain === idmConstants.accountLinksDomain) {
                userId = externalProfile.profile.domainUserId;
            }
            if (!empty(userId)) {
                var oauthProviderId = idmPreferences.oauthProviderId;
                var authenticatedCustomerProfile = CustomerMgr.getExternallyAuthenticatedCustomerProfile(oauthProviderId, userId);
                Transaction.wrap(function () {
                    // Set the user's profile as a cookie (don't allow this to be edited, so set it as HttpOnly).
                    // This will be used onRequest to persist without a 30 minute logout
                    // Fix for Quota api.cookie.maxValueLength (not enforced, warn 1200, limit 2000): limit exceeded.
                    var Cookie = require('dw/web/Cookie');
                    updateIDMCookie(externalProfile, userId, exPRdomain);
                    var profileSizePreferences = {
                        sizePreferences: externalProfile.profile.sizePreferences !== undefined ? externalProfile.profile.sizePreferences : exPRSizePreferences
                    };

                    if (!empty(profileSizePreferences.sizePreferences) && profileSizePreferences.sizePreferences !== undefined) {
                        for (let i = 0; i < profileSizePreferences.sizePreferences.length; i++) {
                            setCookie('UAExternalSizePreferences' + i, JSON.stringify(profileSizePreferences.sizePreferences[i]));
                        }
                    }
                    // Now set a cookie that records the current time -- if the user tries
                    // to access sensitive information (account or cart) after this cookie expires,
                    // make the user reauthenticate.
                    var activeSession = (Date.now() / 1000);
                    var cookie = new Cookie('UAActiveSession', activeSession);
                    cookie.setPath('/');
                    cookie.setHttpOnly(true);
                    response.addHttpCookie(cookie); // eslint-disable-line

                    // If first login with this external authentication provider, create new
                    // customer in SFCC, with the external user ID as the profile's customer
                    // number. SFCC makes a record of the profile customer number on orders
                    // placed by registered customers. We want to be able to easily tie the
                    // order back to the external customer record.
                    var newCustomerRecord;
                    if (!authenticatedCustomerProfile) {
                        // In SFCC, the only way to explicitly set the customer number for a new
                        // customer profile is to create a new customer, which requires setting a
                        // password that meets the password complexity requirements of the site.

                        // To guarantee this, we'll generate a password that meets the most
                        // stringent password complexity requirements possible on SFCC:
                        // * Minimum Password Length: 20
                        // * Minimum special characters: 5 ($%/()[]{}=?!.,-_*|+~#)
                        // * Password Must Contain Letters: True (mixed letter case)
                        // * Password Must Contain Numbers: True

                        // Start with a unique ID, which gives us a string of 26 alphanumeric
                        // characters that is unique and very difficult to guess.
                        var validPassword = require('dw/util/UUIDUtils').createUUID();
                        // Add 5 special chars, uppercase and lowercase letters, and numbers
                        validPassword += '_*|+~aA2';

                        // Create a customer with the external user ID as customer number for the profile
                        newCustomerRecord = CustomerMgr.createCustomer(userId, validPassword, userId);

                        // Add an external authentication profile to the customer record
                        newCustomerRecord.createExternalProfile(oauthProviderId, userId);

                        authenticatedCustomerProfile = newCustomerRecord.getProfile();
                    }


                    var updateProfileOnLogin = idmPreferences.updateProfileOnLogin;
                    if (newCustomerRecord || updateProfileOnLogin) {
                        // Pull required customer profile data from external provider's userInfo response
                        updateCurrentCustomerInfo(authenticatedCustomerProfile, externalProfile);
                        var sizePreferences;
                        if (externalProfile && typeof externalProfile.profile === 'object') {
                            sizePreferences = externalProfile.profile.sizePreferences;
                        }
                        // update size preferences cookie
                        if (sizePreferences || !empty(exPRSizePreferences)) {
                            if (authenticatedCustomerProfile && authenticatedCustomerProfile != null) {
                                authenticatedCustomerProfile.custom.customerSizePreferences = !empty(sizePreferences) ? JSON.stringify(sizePreferences) : JSON.stringify(exPRSizePreferences); // eslint-disable-line
                            }
                        }
                    }
                });
                var credentials = authenticatedCustomerProfile.getCredentials();
                if (credentials.isEnabled()) {
                    Transaction.wrap(function () {
                        customer = CustomerMgr.loginExternallyAuthenticatedCustomer(oauthProviderId, userId, rememberMe);
                    });
                }
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> loginCustomer() :: {0}', e.message);
    }
    return customer;
}
/**
 * Creates IDM account, if there is no account, exists with the specified email address
 * @Param {string} emailAddress - IDM account user name and primary email address
 * @Param {string} password - IDM account password
 * @Param {profObj} profObj - profObj
 * @return {boolean} userCreated - true if IDM user created successfully, else false.
 */
function createUser(emailAddress, password, profObj) {
    const userCreated = {
        status: false,
        errorCode: null
    };
    try {
        if (!empty(emailAddress) && !empty(password)) {
            const tokenResponse = getAccessToken('client_credentials', null);
            if (!empty(tokenResponse) && 'access_token' in tokenResponse && !empty(tokenResponse.access_token)) {
                const accessToken = tokenResponse.access_token;
                const service = idmService.createIDMService();
                service.URL += '/v2/users';
                service.setRequestMethod('POST');
                service.addHeader('Content-Type', 'application/json');
                service.addHeader('Accept', 'application/json');
                service.addHeader('Authorization', 'Bearer ' + accessToken);
                const userInfo = {
                    user: {
                        username: emailAddress,
                        password: password,
                        domain: idmConstants.userDomain,
                        region: request.locale && request.locale != 'default' ? request.locale.split('_')[1] : 'US' //eslint-disable-line
                    },
                    profile: {
                        locale: request.locale // eslint-disable-line
                    },
                    emails: [{
                        email: emailAddress,
                        primary: true
                    }],
                    accountLinks: [{
                        domainUserId: idmConstants.domainUserId,
                        domain: idmConstants.accountLinksDomain
                    }]
                };
                if (!empty(profObj)) {
                    userInfo.profile = profObj;
                }
                const result = service.call(JSON.stringify(userInfo));
                if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object.text)) {
                    const createUserResponse = JSON.parse(result.object.text);
                    if (!empty(createUserResponse.userId)) {
                        // IDM account created successfully
                        session.privacy.userId = createUserResponse.userId_str;
                        userCreated.status = true;
                    }
                } else if (!empty(result)) {
                    userCreated.errorCode = result.error;
                    userCreated.status = false;
                }
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> createUser() :: {0}', e.message);
    }
    return userCreated;
}

/**
 * Prepare the Payload object
 * @Param {Object} createUserObj - createUserObj
 * @return {Object} userInfo - payload object
 */
function getSocialUserPayLoad(createUserObj) {
    const userInfo = {
        uacf_social_provider: createUserObj.providerID,
        uacf_social_appid: ('appID' in createUserObj && !empty(createUserObj.appID)) ? createUserObj.appID : idmPreferences.fbAppID,
        uacf_social_oauthtoken: createUserObj.accessToken,
        domainUserId: idmConstants.domainUserId
    };
    return userInfo;
}
/**
 * Creates IDM account, if there is no account, exists for the Social User in IDM
 * @Param {Object} createUserObj - Social User object to create customer account in IDM
 * @return {boolean} userCreated - true if IDM user created successfully, else false.
 */
function createSocialUser(createUserObj) {
    const userCreated = {
        status: false,
        errorCode: null
    };
    try {
        const tokenResponse = getAccessToken('client_credentials', null);
        if (!empty(tokenResponse) && 'access_token' in tokenResponse && !empty(tokenResponse.access_token)) {
            const accessToken = tokenResponse.access_token;
            const service = idmService.createIDMService();
            service.URL += '/v2/users/social';
            service.setRequestMethod('POST');
            service.addHeader('Content-Type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);

            var createSocialUserPayLoad = getSocialUserPayLoad(createUserObj);

            const result = service.call(JSON.stringify(createSocialUserPayLoad));
            if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object.text)) {
                const createUserResponse = JSON.parse(result.object.text);
                if (!empty(createUserResponse.userId)) {
                    // IDM account created successfully
                    userCreated.status = true;
                }
            } else if (!empty(result)) {
                userCreated.errorCode = result.error;
                userCreated.status = false;
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> createUser() :: {0}', e.message);
    }
    return userCreated;
}
/**
 * Updates IDM account, if there is no account, exists with the specified email address
 * @Param {Object} profileObj - Profile Form
 * @Param {Object} customer - Current Customer
 * @Param {boolean} saveProfile - only save profile
 * @Param {string} customerPreferences - customer preferences
 * @return {boolean} userUpdated - user Updated or not
 */
function updateUser(profileObj, customer, saveProfile, customerPreferences) {
    var userID = '';
    let userObject = {};
    userObject.updated = false;
    userObject.profieObject = '';
    userObject.passwordError = false;
    var takeAccessToken;
    var userName = profileObj.customer.email;
    var password = profileObj.login.password;
    var refreshTokenGenerated = 'not generated';
    try {
        if (!empty(session.privacy.userId)) {
            userID = session.privacy.userId;
        } else {
            var authenticateCustomerResult = {};
            var updateAccessTokenResponse = getNewAccessTokenIfExpired(customer, userName);
            if (updateAccessTokenResponse && 'tokenSuccess' in updateAccessTokenResponse) {
                if (updateAccessTokenResponse.tokenSuccess) {
                    updateTokenOnLogin(customer, updateAccessTokenResponse);
                    refreshTokenGenerated = 'generated';
                } else {
                    refreshTokenGenerated = 'error';
                }
            }
            if (refreshTokenGenerated === 'error') {
                userObject.refreshtokenGenerationError = true;
                return userObject;
            }
            if (saveProfile && customer.profile && customer.profile.custom && 'idmAccessToken' in customer.profile.custom && customer.profile.custom.idmAccessToken) {
                authenticateCustomerResult = {
                    accessToken: customer.profile.custom.idmAccessToken,
                    tokenSuccess: true
                };
            } else {
                authenticateCustomerResult = authenticateCustomer(userName, password);
            }
            if (authenticateCustomerResult.tokenSuccess && authenticateCustomerResult.accessToken) {
                var customerInfo = getCustomerInfo(authenticateCustomerResult.accessToken);
                if (!empty(customerInfo)) {
                    userID = customerInfo.sub; // OpenID Connect standard claim;
                }
            }
        }
        if (!empty(profileObj) && !empty(userID)) {
            // Get IDM access token for just registered customer
            if (!empty(session.privacy.userId)) {
                // 1. Try to get from profile (expires 1 hour after creation)
                takeAccessToken = getTokenFromProfile();
                // 2. Else get from service call
                if (!takeAccessToken) {
                    const accessTokenResponse = getAccessToken('client_credentials', null);
                    if (!empty(accessTokenResponse) && 'access_token' in accessTokenResponse && !empty(accessTokenResponse.access_token)) {
                        takeAccessToken = accessTokenResponse.access_token;
                    }
                }
            }

            var tokenResponse = empty(session.privacy.userId) ? authenticateCustomerResult.accessToken : takeAccessToken; // eslint-disable-line block-scoped-var
            var bdyYear = profileObj.customer && profileObj.customer.birthYear ? profileObj.customer.birthYear : customer.profile.custom.birthYear;
            if (bdyYear === 0) {
                bdyYear = null;
            }
            var bdyMonth = profileObj.customer && profileObj.customer.birthMonth ? profileObj.customer.birthMonth : customer.profile.custom.birthMonth;
            if (bdyMonth === 0) {
                bdyMonth = null;
            }
            var bdyDay = profileObj.customer && profileObj.customer.birthDay ? profileObj.customer.birthDay : customer.profile.custom.birthDay;
            if (bdyDay === 0) {
                bdyDay = null;
            }
            var gender = null;
            if (profileObj.customer && profileObj.customer.gender == 1) {// eslint-disable-line
                gender = 'MALE';
            } else if (profileObj.customer && profileObj.customer.gender == 2) {// eslint-disable-line
                gender = 'FEMALE';
            }
            var preferences = !empty(customerPreferences) ? customerPreferences : accountHelpers.getPreferences(profileObj);

            if (!empty(tokenResponse)) {
                const accessToken = tokenResponse;
                const service = idmService.createIDMService();
                service.URL += '/v2/users/' + userID;
                service.setRequestMethod('PATCH');
                service.addHeader('Content-Type', 'application/json');
                service.addHeader('Accept', 'application/json');
                service.addHeader('Authorization', 'Bearer ' + accessToken);
                var phone = '';
                if (profileObj.customer.phone) {
                    phone = profileObj.customer.phone;
                } else {
                    phone = customer.profile.phoneHome;
                }
                const userInfo = {
                    user: {
                        username: profileObj.customer.newemail ? profileObj.customer.newemail : customer.profile.email,
                        password: profileObj.login && profileObj.login.newPassword ? profileObj.login.newPassword : null,
                        domain: idmConstants.userDomain
                    },
                    profile: {
                        firstName: profileObj.customer.firstname ? profileObj.customer.firstname : customer.profile.firstName,
                        lastName: profileObj.customer.lastname ? profileObj.customer.lastname : customer.profile.lastName,
                        phone: profileObj.customer.countryDialingCode ? profileObj.customer.countryDialingCode + '-' + phone : phone,
                        gender: gender,
                        birthdate_obj: {
                            month: bdyMonth,
                            day: bdyDay
                        },
                        location: {
                            postalCode: profileObj.customer.postalCode ? profileObj.customer.postalCode : customer.profile.custom.zipCode
                        },
                        preferences: preferences
                    },
                    emails: [{
                        email: profileObj.customer.newemail ? profileObj.customer.newemail : customer.profile.email,
                        primary: true
                    }]
                };
                if (bdyYear) {
                    userInfo.profile.birthdate_obj.year = bdyYear;
                }
                const result = service.call(JSON.stringify(userInfo));
                if (!empty(result) && !empty(result.status) && result.status === 'OK' && !empty(result.object.text)) {
                    const updatedUserResponse = JSON.parse(result.object.text);
                    if (!empty(updatedUserResponse.userId)) {
                        // IDM account updated successfully
                        userObject.updated = true;
                        userObject.profieObject = updatedUserResponse;

                        // IDM does not return birthYear after PATCH request. Update it manually if present
                        if (bdyYear && updatedUserResponse.profile && updatedUserResponse.profile.birthdate_obj && !updatedUserResponse.profile.birthdate_obj.year) {
                            updatedUserResponse.profile.birthdate_obj.year = +bdyYear;
                        }
                        updateIDMCookie(updatedUserResponse);
                    }
                }
            }
        } else {
            userObject.passwordError = true;
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> updateUser() :: {0}', e.message);
    }
    return userObject; // eslint-disable-line
}
/**
 * Updates Profile in SFCC
 * @Param {Object} res - Current Response
 * @Param {Object} customer - Current Customer
 * @Param {Object} externalProfile - externalProfile
 */
function updateProfile(res, customer, externalProfile) {
    var firstName;
    var lastName;
    var email;
    var birthdayObj;
    var gender;
    var profilePictureUri;
    var phoneNumber;
    var countryDialingCode;
    var postalCode;
    var preferences;
    var status;
    var customerLogin;
    var formInfo = res.getViewData();
    var profile = customer.getProfile();
    var profileForm = server.forms.getForm('profile');
    var profileObject = externalProfile && externalProfile.profile ? externalProfile.profile : null;
    var emailID = profile.email;
    var emailObject = externalProfile && externalProfile.emails ? externalProfile.emails : null;
    var newUser = session.privacy.registeredURL;
    for (var externalEmail in emailObject) { // eslint-disable-line
        if (emailObject[externalEmail].primary) {
            emailID = emailObject[externalEmail].email;
        }
    }
    if (profileObject === null) {
        if (empty(newUser)) {
            Transaction.wrap(function () {
                status = profile.credentials.setPassword(
                    formInfo.password,
                    formInfo.password,
                    true
                );
                if (status.error) {
                    formInfo.profileForm.login.password.valid = false;
                    formInfo.profileForm.login.password.error = Resource.msg('error.message.currentpasswordnomatch', 'forms', null);
                } else {
                    customerLogin = profile.credentials.setLogin(
                        formInfo.newEmail ? formInfo.newEmail : formInfo.email,
                        formInfo.password
                    );
                }
            });
        }
    }
    var month = formInfo.birthMonth;
    var day = formInfo.birthDay;
    var year = formInfo.birthYear ? formInfo.birthYear : null;
    if (profileObject) {
        firstName = profileObject && profileObject.firstName ? profileObject.firstName : '';
        lastName = profileObject && profileObject.lastName ? profileObject.lastName : '';
        gender = profileObject && profileObject.gender ? profileObject.gender : '';
        profilePictureUri = profileObject && !empty(profileObject.profilePictureUri) ? profileObject.profilePictureUri : '';
        birthdayObj = profileObject.birthdate_obj;
        phoneNumber = profileObject && profileObject.phone ? profileObject.phone : '';
        if (phoneNumber.indexOf('-') >= 0) {
            var Ph = phoneNumber.split('-');
            if (Ph.length === 2) {
                phoneNumber = Ph[1];
                countryDialingCode = Ph[0];
            }
        }
        postalCode = profileObject && profileObject.location ? profileObject.location.postalCode : '';
        preferences = profileObject && profileObject.preferences ? JSON.stringify(profileObject.preferences) : '';
        email = emailID;
        month = birthdayObj.month;
        day = birthdayObj.day;
        year = birthdayObj.year ? birthdayObj.year : 0;
    } else {
        firstName = formInfo.firstName;
        lastName = formInfo.lastName;
        gender = formInfo.gender;
        phoneNumber = formInfo.phone;
        countryDialingCode = formInfo.countryDialingCode;
        postalCode = formInfo.zipCode;
        preferences = formInfo.preferences;
        email = formInfo.email;
        profilePictureUri = profile.custom.profilePictureUri;
    }
    var birthday = null;
    if (month && month !== 0 && day && day !== 0) {
        if (year && year !== 0) {
            birthday = new Date(year, month - 1, day);
        } else {
            birthday = new Date('0000', month - 1, day);
        }
    }
    if (gender) {
        // Case-insensitive match vs. values of Profile.gender system attribute
        // (Enum of Int type), configurable in Business Manager.

        var genderAttrDef = profile.describe().getSystemAttributeDefinition('gender');
        var genderAttrValues = genderAttrDef.getValues();
        genderAttrValues = genderAttrValues.toArray();
        var genderAttrMatch = genderAttrValues.filter(function (attrValue) {
            return (RegExp('^' + gender + '$', 'i').test(attrValue.getDisplayValue()));
        }).pop();

        if (genderAttrMatch) {
            gender = genderAttrMatch.value;
        }
    }

    if (!gender) gender = 0;
    if (customerLogin || profileObject || !empty(newUser)) {
        Transaction.wrap(function () {
            profile.setFirstName(firstName);
            profile.setLastName(lastName);
            profile.setEmail(email);
            profile.setPhoneHome(phoneNumber);
            profile.setGender(gender);
            if (profile && countryDialingCode) {
                profile.custom.countryDialingCode = countryDialingCode;
            }
            profile.custom.zipCode = postalCode;
            profile.custom.preferences = preferences;
            profile.setBirthday(birthday);
            if (day) {
                profile.custom.birthDay = day.toString();
            }
            if (month) {
                profile.custom.birthMonth = month.toString();
            }
            if (year) {
                profile.custom.birthYear = year.toString();
            }
            // For MX we also store birthday in 'dob' attribute
            if (isMX && day && month && year) {
                var dob = day + '/' + month + '/' + year;
                // Transform D/M/YYYY to DD/MM/YYYY
                dob = dob.replace(/\b\d\b/g, '0$&');
                profile.custom.dob = dob;
            }
            profile.custom.profilePictureUri = profilePictureUri;
        });
        delete formInfo.password;
        delete formInfo.profileForm;
        delete formInfo.email;
        accountHelpers.sendAccountEditedEmail(customer.profile);
        delete session.privacy.userId;
        delete session.privacy.registeredURL;
        res.json({
            success: true,
            redirectUrl: URLUtils.url('Account-EditProfile').toString()
        });
    } else {
        if (!status.error) {
            formInfo.profileForm.customer.email.valid = false;
            formInfo.profileForm.customer.email.error =
                Resource.msg('error.message.username.invalid', 'forms', null);
        }
        delete formInfo.profileForm;
        delete formInfo.email;
        delete session.privacy.userId;
        delete session.privacy.registeredURL;
        res.json({
            success: false,
            errorMessage: status.error ? status.message : Resource.msg('error.message.username.invalid', 'forms', null),
            fields: formErrors.getFormErrors(profileForm)
        });
    }
}
/**
 * Updates Password in SFCC
 * @Param {Object} res - Current Response
 * @Param {Object} customer - Current Customer
 */
function updatePassword(res, customer) {
    var formInfo = res.getViewData();
    var profileForm = server.forms.getForm('profile');
    var status;
    Transaction.wrap(function () {
        status = customer.profile.credentials.setPassword(
            formInfo.newPassword,
            formInfo.currentPassword,
            true
        );
    });
    if (status.error) {
        formInfo.profileForm.login.currentpassword.valid = false;
        formInfo.profileForm.login.currentpassword.error =
            Resource.msg('error.message.currentpasswordnomatch', 'forms', null);
        delete formInfo.currentPassword;
        delete formInfo.newPassword;
        delete formInfo.newPasswordConfirm;
        delete formInfo.profileForm;

        res.json({
            success: false,
            errorMessage: Resource.msg('error.message.currentpasswordnomatch', 'forms', null),
            fields: formErrors.getFormErrors(profileForm)
        });
    } else {
        var emailHelpers = require('*/cartridge/scripts/helpers/emailHelpers');
        var email = customer.profile.email;
        var url = URLUtils.https('Home-Show', 'showLoginModel', true);
        var objectForEmail = {
            firstName: customer.profile.firstName,
            lastName: customer.profile.lastName,
            url: url
        };

        var emailObj = {
            to: email,
            subject: Resource.msg('subject.profile.resetpassword.email', 'login', null),
            from: Site.current.getCustomPreferenceValue('customerServiceEmail') || 'no-reply@salesforce.com',
            type: emailHelpers.emailTypes.passwordReset
        };

        emailHelpers.sendEmail(emailObj, 'account/password/passwordChangedEmail', objectForEmail);
        delete formInfo.currentPassword;
        delete formInfo.newPassword;
        delete formInfo.newPasswordConfirm;
        delete formInfo.profileForm;

        res.json({
            success: true,
            successMessage: Resource.msg('success.password.changed', 'account', null),
            redirectUrl: URLUtils.url('Account-EditProfile').toString()
        });
    }
}

/**
 * Password Reset service call
 * @param {string} email input to be validated
 * @param {string} clientToken IDM access token
 * @returns {Object} status of response
 */
function passwordReset(email, clientToken) {
    var passwordResetStatus = {
        status: false,
        errorCode: Resource.msg('error.message.passwordreset', 'login', null)
    };
    try {
        if (clientToken) {
            const accessToken = clientToken;
            const service = idmService.createIDMService();
            service.URL += '/password_reset?operation=initiate';
            service.setRequestMethod('POST');
            service.addHeader('Content-Type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);
            const data = {
                app_name: idmPreferences.accountLinksDomain,
                email: email,
                redirect_uri: URLUtils.abs('Home-Show').toString(),
                password_reset_uri: URLUtils.abs('Account-SetNewPassword').toString() + '?token='
                // requires URL Rules > Pipeline URLs in Business Managet to map "setpassword" to "Account-SetNewPassword"
                // example password_reset_url result: 'https://dev07-ua03-us.sfcc.ua-ecm.com/en-us/setpassword?token='
            };
            const result = service.call(JSON.stringify(data));
            if (!empty(result) && !empty(result.status) && result.status === 'OK') {
                passwordResetStatus.status = true;
                passwordResetStatus.errorCode = null;
            }
        }
    } catch (e) {
        passwordResetStatus.status = false;
        passwordResetStatus.errorCode = e.message;
    }
    return passwordResetStatus;
}

/**
 * validates user IDM
 * @param {string} token user token
 * @returns {Object} status and user ID
 */
function verifyNewPasswordIDMAccount(token) {
    var passwordResetStatus = {
        status: false,
        userId: null
    };
    try {
        const tokenResponse = getAccessToken('client_credentials', null);
        if (tokenResponse) {
            const accessToken = tokenResponse.access_token;
            const service = idmService.createIDMService();
            service.URL += '/password_reset?operation=peek';
            service.setRequestMethod('POST');
            service.addHeader('Content-Type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);
            const data = {
                token: token
            };
            const result = service.call(JSON.stringify(data));
            if (!empty(result) && !empty(result.status) && result.status === 'OK') {
                passwordResetStatus.status = true;
                var createUserResponse = JSON.parse(result.object.text);
                if (!empty(createUserResponse.user_id)) {
                    passwordResetStatus.userId = createUserResponse.user_id;
                }
            }
        }
    } catch (e) {
        passwordResetStatus.status = false;
    }
    return passwordResetStatus;
}

/**
 * update new password to user in IDM
 * @param {string} token user token
 * @param {string} newPassword password
 * @returns {boolean} status
 */
function updateNewPasswordIDMAccount(token, newPassword) {
    var passwordResetStatus = false;
    try {
        const tokenResponse = getAccessToken('client_credentials', null);
        if (tokenResponse) {
            const accessToken = tokenResponse.access_token;
            const service = idmService.createIDMService();
            service.URL += '/password_reset?operation=reset';
            service.setRequestMethod('POST');
            service.addHeader('Content-Type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + accessToken);
            const data = {
                token: token,
                password: newPassword
            };
            const result = service.call(JSON.stringify(data));
            if (!empty(result) && !empty(result.status) && result.status === 'OK') {
                passwordResetStatus = true;
            }
        }
    } catch (e) {
        passwordResetStatus = false;
    }
    return {
        error: !passwordResetStatus
    };
}

/**
 * Deletes the given account link
 * @param {string} linkDomainUID account link domain uid
 * @param {string} dwDomain IDM domain
 * @returns {Object} api response or error object
 */
function deleteAccountLink(linkDomainUID, dwDomain) {
    try {
        const tokenResponse = getAccessToken('client_credentials', null);
        if (!empty(tokenResponse.access_token)) {
            const service = idmService.createIDMService();
            service.URL += '/accountlinks/' + linkDomainUID + '-' + dwDomain; // eslint-disable-line spellcheck/spell-checker
            service.setRequestMethod('DELETE');
            service.addHeader('content-type', 'application/json');
            service.addHeader('Accept', 'application/json');
            service.addHeader('Authorization', 'Bearer ' + tokenResponse.access_token);
            service.addHeader('X-HTTP-Method-Override', 'DELETE');
            const result = service.call();
            if (!empty(result) && !empty(result.status) && result.status === 'OK') {
                return {
                    status: true
                };
            } else if (result.errorMessage) {
                idmLogger.error('Error in IDMHelper.js -> deleteAccountLink() :: {0}', result.errorMessage);
            }
        }
    } catch (e) {
        idmLogger.error('Error in IDMHelper.js -> deleteAccountLink() :: {0}', e.message);
    }
    return {
        status: false
    };
}

module.exports = {
    authenticateCustomer: authenticateCustomer,
    loginCustomer: loginCustomer,
    createUser: createUser,
    updateUser: updateUser,
    updateProfile: updateProfile,
    updatePassword: updatePassword,
    errorCodes: errorCodes,
    customerInfo: getCustomerInfo,
    customerLoyaltyInfo: getCustomerLoyaltyInfo,
    passwordReset: passwordReset,
    verifyNewPasswordIDMAccount: verifyNewPasswordIDMAccount,
    updateNewPasswordIDMAccount: updateNewPasswordIDMAccount,
    createSocialUser: createSocialUser,
    getAccessToken: getAccessToken,
    getUserIDByEmail: getUserIDByEmail,
    updateIDMLocale: updateIDMLocale,
    updateSizePreferences: updateSizePreferences,
    updateCurrentCustomerInfo: updateCurrentCustomerInfo,
    updateTokenOnLogin: updateTokenOnLogin,
    getNewAccessTokenIfExpired: getNewAccessTokenIfExpired,
    deleteAccountLink: deleteAccountLink
};
